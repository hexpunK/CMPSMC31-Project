package uk.ac.uea.mathsthing;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

/**
 * Provides implementation of the Lexer Interface. This includes
 * tokenising a given formula including parameters
 * @author Laura Goold
 *
 */

public class Lexer implements IFormulaLexer{
	
	private String input;
	private String userEquation; //equation given by user in original form
	private Token[] tokens; //array to store tokens generated by pattern matcher
	
	private ArrayList<Token> equation; //tokenised equation
	private HashMap<String, Integer> parameters;
	
	/**
	 * Constructor for Lexer class, intialises all class variables
	 */
	public Lexer()
	{
		input="";
		userEquation = "";
		tokens = new Token[0];
		equation = new ArrayList<>();
		parameters = new HashMap<String, Integer>();
	}
	
	/**
	 * Constructor for Lexer class
	 * @param in String representing user input
	 */
	public Lexer(String in)
	{
		input = in;
		userEquation = "";
		tokens = new Token[0];
		equation = new ArrayList<>();
		parameters = new HashMap<String, Integer>();
	}

	@Override
	public String getUserFormula() {
		
		int i = input.indexOf(":");
		if (i >= 0)
			userEquation = input.substring(0, i); //get equation from original input
		else
			userEquation = input; //no parameters so input just contains equation
		return userEquation;
	}

	@Override
	public String getProccessedFormula() {
		
		StringBuilder output = new StringBuilder();
		
		for(Token token : tokens) {
			output.append(token);
			//loop through all tokens adding to final string representation
		}
		
		return output.toString();
	}

	@Override
	public Token[] tokenize(String formula) {

		this.input = formula;
		String orig = getUserFormula();
		orig.trim();
		orig = orig.replaceAll("\\s+", ""); //remove all whitespace from formula
		
		//create the patter to match
		Pattern p1 = Pattern.compile(TokenType.FUNCTION.getToken() + "|" + TokenType.OPERATOR.getToken() +
				"|" + TokenType.OPERAND.getToken() + "|" + TokenType.CONSTANT.getToken());
		
		//set up the matcher using the pattern created
		Matcher mat = p1.matcher(orig);
		
		//loop through all matches, convert them to tokens and add to the tokenised equation
		while(mat.find())
		{
			//function
			if(mat.group(TokenType.FUNCTION.ordinal()+1) != null)
			{
				Token t = new Token(mat.group(TokenType.FUNCTION.ordinal()+1), TokenType.FUNCTION);
				equation.add(t);
			}
			//operator
			if(mat.group(TokenType.OPERATOR.ordinal()+1) != null)
			{
				Token t = new Token(mat.group(TokenType.OPERATOR.ordinal()+1), TokenType.OPERATOR);
				equation.add(t);
			}
			//operand
			if(mat.group(TokenType.OPERAND.ordinal()+1) != null)
			{
				Token t = new Token(mat.group(TokenType.OPERAND.ordinal()+1), TokenType.OPERAND);
				equation.add(t);
			}
			//constant
			if(mat.group(TokenType.CONSTANT.ordinal()+1) != null) //matcher indexes groups from 1
			{
				Token t = new Token(mat.group(TokenType.CONSTANT.ordinal()+1), TokenType.CONSTANT);
				equation.add(t);
			}
		}
		
		this.tokens = equation.toArray(this.tokens);
		
		return this.tokens;
	}
	
	@Override
	public Token[] getTokens() {
		
		return this.tokens;
	}

	@Override
	public HashMap<String, Integer> getParameters() {
		int index = input.indexOf(":"); 
		String allP = input.substring(index+1); //get list of parameters from original input
		
		String[] params = allP.split(","); //separate the parameters
		
		for(int i=0; i< params.length; i++)
		{
			String[] p = params[i].split("="); //split into letter and assigned value
			parameters.put(p[0], Integer.parseInt(p[1]));
		}
		
		//return null;
		return parameters;
	}
	

}
